# **Отчет по развертыванию, использованию и проверке Label Studio (с использованием Docker)**

Этот документ описывает процесс установки, настройки, использования и проверки инструмента разметки данных Label Studio. Инструкции адаптированы для пользователей операционных систем **Windows** и **Linux** и предполагают развертывание исключительно с использованием технологии контейнеризации **Docker**.

## 1. Развертывание Label Studio

### 1.1. Предварительные требования
*   **Установленный Docker:**
    *   **Windows/macOS:** Docker Desktop.
    *   **Linux:** Docker Engine. Рекомендуется убедиться, что текущий пользователь добавлен в группу `docker` (чтобы избежать необходимости использовать `sudo` для каждой Docker-команды).
*   **Доступ в Интернет:** Необходим для скачивания официального Docker-образа Label Studio.
*   **Python 3.x (опционально, для скрипта проверки):** С установленными библиотеками `opencv-python` и `numpy`. Установка может быть выполнена командой:
    ```bash
    pip install opencv-python numpy
    ```
    *Рекомендуется использовать виртуальное окружение для Python-проектов.*

### 1.2. Выбор способа развертывания
Для локального развертывания Label Studio с обеспечением персистентности данных (сохранения проектов и аннотаций между сессиями) используется запуск Docker-контейнера с монтированием тома (bind mount) из файловой системы хоста. Этот метод обеспечивает:
*   **Сохранность данных:** Все проекты, импортированные данные и сделанные аннотации будут сохранены в указанной локальной директории даже после остановки или удаления контейнера.
*   **Прямой доступ к файлам проекта:** Позволяет легко получать доступ к файлам базы данных Label Studio, загруженным медиафайлам и экспортированным аннотациям непосредственно с хост-машины.

### 1.3. Шаги развертывания

1.  **Создание локальной директории для данных Label Studio:**
    Необходимо создать на хост-машине директорию, в которой будут храниться все данные, генерируемые Label Studio. **Абсолютный путь к этой директории потребуется на следующем шаге.**

    *   **Для Windows (в PowerShell):**
        Замените `C:\путь\к\вашей\папке` на фактический путь. Например, `C:\Users\YourUser\Documents\LabelStudioProjects`.
        ```powershell
        mkdir C:\путь\к\вашей\папке\label_studio_data 
        # Пример из исходного отчета:
        # mkdir C:\Users\maxku\Desktop\comparing-data-markup\label_studio_data
        ```
        Альтернативно, директорию `label_studio_data` можно создать через Проводник Windows.

    *   **Для Linux (в терминале):**
        Замените `/путь/к/вашей/папке` на фактический путь. Например, `/home/youruser/LabelStudioProjects`.
        ```bash
        mkdir -p /путь/к/вашей/папке/label_studio_data
        # Пример:
        # mkdir -p ~/projects/label_studio_data
        ```

2.  **Запуск контейнера Label Studio:**
    Откройте терминал (PowerShell для Windows, Bash или аналогичный терминал для Linux) и выполните команду, соответствующую вашей операционной системе.

    *   **Для Windows (в PowerShell):**
        Замените `C:\путь\к\вашей\папке\label_studio_data` на полный путь к директории, созданной на предыдущем шаге.
        ```powershell
        docker run -d -p 8080:8080 -v C:\путь\к\вашей\папке\label_studio_data:/label-studio/data --name label-studio-instance heartexlabs/label-studio
        # Пример из исходного отчета (рекомендую сменить имя контейнера на более общее, если это шаблон):
        # docker run -d -p 8080:8080 -v C:\Users\maxku\Desktop\comparing-data-markup\label_studio_data:/label-studio/data --name label-studio-container heartexlabs/label-studio
        ```

    *   **Для Linux (в терминале):**
        Замените `/путь/к/вашей/папке/label_studio_data` на полный путь к директории, созданной на предыдущем шаге.
        ```bash
        docker run -d -p 8080:8080 -v /путь/к/вашей/папке/label_studio_data:/label-studio/data --name label-studio-instance heartexlabs/label-studio
        # Пример:
        # docker run -d -p 8080:8080 -v ~/projects/label_studio_data:/label-studio/data --name label-studio-container heartexlabs/label-studio
        ```

    **Разбор команды `docker run`:**
    *   `-d`: Запуск контейнера в фоновом (detached) режиме.
    *   `-p 8080:8080`: Проброс порта 8080 хост-машины на порт 8080 внутри контейнера, где работает веб-сервер Label Studio.
    *   `-v [ПУТЬ_НА_ХОСТЕ_К_label_studio_data]:/label-studio/data`: Монтирование тома (bind mount).
        *   `[ПУТЬ_НА_ХОСТЕ_К_label_studio_data]`: Абсолютный путь к созданной вами директории на хост-машине.
        *   `:/label-studio/data`: Путь внутри контейнера, который Label Studio использует для хранения своих данных. **Эту часть изменять не следует.**
    *   `--name label-studio-instance`: Присвоение контейнеру кастомного имени (например, `label-studio-instance` или `my-label-studio`) для удобства управления им через команды Docker (например, `docker stop label-studio-instance`).
    *   `heartexlabs/label-studio`: Официальное имя Docker-образа Label Studio на Docker Hub. Можно указать конкретную версию, например, `heartexlabs/label-studio:latest` или `heartexlabs/label-studio:1.11.0`.

3.  **Проверка статуса контейнера:**
    Убедитесь, что контейнер успешно запущен и работает:
    ```bash
    docker ps
    ```
    В выводе команды вы должны увидеть контейнер с именем `label-studio-instance` (или тем, которое вы задали) и статусом `Up ...`.

4.  **Доступ к Label Studio и создание аккаунта:**
    Откройте веб-браузер и перейдите по адресу `http://localhost:8080`.
    При первом входе Label Studio предложит создать учетную запись администратора. Заполните необходимые поля (email, пароль) и войдите в систему.

### 1.4. Структура хранения данных на хост-машине
После запуска Label Studio и выполнения операций (например, создания проектов, импорта данных), в директории, смонтированной из хост-системы (например, `C:\путь\к\вашей\папке\label_studio_data` или `/путь/к/вашей/папке/label_studio_data`), будет автоматически сформирована следующая структура файлов и папок:
```
[ВАША_ДИРЕКТОРИЯ_НА_ХОСТЕ]/label_studio_data/
├── export/                     # Директория для экспортированных аннотаций
│   └── project-1-at-....json   # Пример файла с экспортированными аннотациями
├── media/                      # Директория для загруженных медиафайлов
│   └── upload/
│       └── 1/                  # Директория для файлов проекта с ID=1
│           ├── example-image1.jpg
│           └── ...             # Другие загруженные файлы для проекта 1
├── label_studio.sqlite3        # База данных SQLite, где хранятся метаданные проектов, задач, пользователей и т.д.
└── config.json                 # Основной конфигурационный файл Label Studio
...                             # Другие служебные файлы и директории
```
**Важно понимать:** Пути к загруженным файлам, которые Label Studio использует внутри себя и указывает в экспортированных JSON-файлах (например, в поле `data.image`), будут относительными к внутренней структуре контейнера и обычно начинаются с `/data/upload/...`. При доступе к этим файлам с вашего хост-компьютера для внешней обработки (например, в Python-скрипте), вам необходимо будет корректно сопоставить этот внутренний путь с путем на вашей локальной машине: `[ВАША_ДИРЕКТОРИЯ_НА_ХОСТЕ]/label_studio_data/media/upload/...`.

### 1.5. Возможные сложности и их решения при развертывании и настройке

*   **Проблема: Ошибка "There was an issue loading URL from $undefined$ value" (или аналогичная) при отображении данных для разметки (например, изображений).**
    *   **Симптом:** Вместо изображения или текста в интерфейсе разметки отображается сообщение об ошибке загрузки URL, часто упоминающее `$undefined$` или неверное имя переменной.
    *   **Причина:** Некорректное значение атрибута `value` в XML-теге, отвечающем за отображение данных в интерфейсе разметки (например, `<Image value="...">`, `<Text value="...">`). По умолчанию, при создании конфигурации вручную или при ошибке импорта, эта переменная может быть неверно определена.
    *   **Решение:**
        1.  В интерфейсе Label Studio откройте ваш проект.
        2.  Перейдите в "Settings" (Настройки) проекта, затем в раздел "Labeling Interface" (Интерфейс разметки).
        3.  На вкладке "Code" (Код) найдите XML-тег, который отвечает за отображение ваших данных (например, `<Image name="image" value="$image"/>`).
        4.  Убедитесь, что атрибут `value` (или аналогичный, зависящий от типа данных и тега) установлен в `$[имя_поля_с_данными]`. Имя поля должно соответствовать ключу, под которым ваши данные хранятся в каждой задаче.
            *   Для файлов, загруженных стандартным образом через UI, это обычно `image` для изображений, `text` для текста, `audio` для аудио. Таким образом, правильно будет `value="$image"`, `value="$text"` и т.д.
            *   Если данные импортировались из CSV или JSON с кастомными именами колонок/ключей (например, колонка `article_content` в CSV), то следует использовать `value="$article_content"`.

## 2. Тестовая разметка: Детекция кошек на изображениях

### 2.1. Создание проекта
*   В веб-интерфейсе Label Studio была нажата кнопка "Create Project".
*   Проекту было присвоено имя: `Cat Detection Test`.
*   Цель проекта: разметка изображений для задачи детекции объектов путем выделения их ограничивающими прямоугольниками (bounding boxes).

### 2.2. Подготовка и импорт датасета
*   **Данные:** Для тестовой разметки был подготовлен набор из 14 изображений с кошками.
*   **Источник:** Изображения были загружены с общедоступного ресурса Pexels.com.
*   **Формат:** Все изображения были в формате `.jpg`.
*   **Процесс импорта:**
    1.  В созданном проекте `Cat Detection Test` была использована функция "Import".
    2.  Выбран метод "File Upload".
    3.  Подготовленные 14 файлов изображений были выбраны и загружены в проект.

### 2.3. Настройка интерфейса разметки (Labeling Interface)
Для задачи детекции объектов с использованием ограничивающих прямоугольников была настроена следующая XML-конфигурация интерфейса разметки:
1.  В настройках проекта ("Settings" -> "Labeling Interface", вкладка "Code").
2.  Использована следующая XML-структура:
    ```xml
    <View>
      <!-- Отображение изображения. "$image" - стандартная переменная для загруженных изображений. -->
      <Image name="image" value="$image" zoom="true" zoomControl="true" rotateControl="true"/>
      
      <!-- Инструмент для создания прямоугольных меток, привязанный к изображению "image". -->
      <RectangleLabels name="label" toName="image">
        <Label value="Cat" background="#007bff"/> <!-- Синий цвет для одиночных кошек -->
        <Label value="Cats_Group" background="#28a745"/> <!-- Зеленый цвет для группы кошек -->
      </RectangleLabels>
    </View>
    ```
    *   **Пояснения к конфигурации:**
        *   `<Image name="image" value="$image" zoom="true" zoomControl="true" rotateControl="true"/>`: Отображает изображение из поля `image` задачи и включает элементы управления масштабированием и поворотом.
        *   `<RectangleLabels name="label" toName="image">`: Определяет, что для элемента с именем `image` будут использоваться инструменты для создания прямоугольных меток. `name="label"` - это идентификатор для группы меток.
        *   `<Label value="Cat" background="#007bff"/>`: Определяет метку (класс) "Cat" с синим цветом фона для визуального выделения.
        *   `<Label value="Cats_Group" background="#28a745"/>`: Определяет метку "Cats_Group" (для обозначения группы из нескольких кошек, если это требуется задачей) с зеленым цветом.
3.  Конфигурация была сохранена кнопкой "Save".

### 2.4. Выполнение разметки
*   Переход к разметке осуществлялся с главной страницы проекта через кнопку "Label All Tasks" (Разметить все задачи).
*   Для каждого из 14 изображений были выполнены следующие действия:
    1.  Выбор инструмента "Rectangle" (Прямоугольник) на панели инструментов.
    2.  Выбор соответствующей метки ("Cat" или "Cats_Group") из списка доступных меток.
    3.  Отрисовка ограничивающего прямоугольника вокруг каждого целевого объекта (кошки или группы кошек) на изображении.
    4.  После завершения разметки всех объектов на текущем изображении нажималась кнопка "Submit" (Отправить) для сохранения аннотаций и автоматического перехода к следующей задаче.
*   Таким образом, были размечены все 14 изображений.

## 3. Экспорт и проверка разметки

### 3.1. Экспорт данных
*   После завершения аннотирования всех задач, на странице проекта была нажата кнопка "Export".
*   В качестве формата экспорта был выбран **JSON**, так как он предоставляет наиболее полную информацию об аннотациях и структуре данных, удобную для дальнейшей программной обработки.
*   Файл с аннотациями (например, `project-1-at-YYYY-MM-DD-HH-MM-hash.json`) был успешно скачан на локальный компьютер.
*   **Пример структуры экспортированного JSON для одной аннотированной задачи (ключевые поля):**
    ```json
    [
      {
        "id": 1, // Внутренний ID задачи в Label Studio
        "annotations": [
          {
            "id": 123, // Внутренний ID аннотации
            "completed_by": 1, // ID пользователя-разметчика
            "result": [ // Массив размеченных элементов
              {
                "original_width": 3606,  // Исходная ширина изображения в пикселях
                "original_height": 5409, // Исходная высота изображения в пикселях
                "image_rotation": 0,     // Угол поворота изображения (если применялся)
                "value": {
                  "x": 29.47,  // Координата X левого верхнего угла рамки (в % от ширины)
                  "y": 17.61,  // Координата Y левого верхнего угла рамки (в % от высоты)
                  "width": 47.76, // Ширина рамки (в % от ширины изображения)
                  "height": 69.64, // Высота рамки (в % от высоты изображения)
                  "rotation": 0,
                  "rectanglelabels": ["Cat"] // Список присвоенных меток (здесь одна - "Cat")
                },
                "id": "GeneratedUniqID", // Уникальный ID этого элемента разметки
                "from_name": "label",   // Ссылка на 'name' из <RectangleLabels>
                "to_name": "image",     // Ссылка на 'name' из <Image>
                "type": "rectanglelabels", // Тип элемента разметки
                "origin": "manual"      // Указывает, что разметка сделана вручную
              }
              // ... могут быть другие размеченные прямоугольники для этого изображения ...
            ]
            // ... другие метаданные аннотации ...
          }
        ],
        "file_upload": "filename.jpg", // Имя исходного загруженного файла
        "data": {
          // Ключ 'image' соответствует value="$image" в XML-конфигурации
          "image": "/data/upload/1/filename.jpg" // Путь к файлу ВНУТРИ Docker-контейнера
        }
        // ... другие метаданные задачи ...
      }
      // ... другие задачи в экспорте ...
    ]
    ```

### 3.2. Проверка разметки с помощью Python-скрипта
Для визуальной верификации корректности экспортированных аннотаций был разработан и использован Python-скрипт, использующий библиотеку OpenCV.

**Ключевые аспекты реализации скрипта:**

1.  **Определение базового пути к данным Label Studio на хост-машине:** Скрипт требует указания пути к директории, которая была смонтирована в Docker-контейнер Label Studio (например, `C:\Users\maxku\Desktop\comparing-data-markup\label_studio_data`).
2.  **Корректное формирование пути к изображениям на хосте:**
    *   JSON-файл экспорта содержит пути к изображениям в формате, используемом внутри контейнера (например, `/data/upload/PROJECT_ID/filename.jpg`).
    *   Скрипт преобразует эти внутренние пути в абсолютные пути на хост-машине, заменяя префикс `/data/` на путь к поддиректории `media/` внутри основной смонтированной директории Label Studio. Использование `os.path.join` и `os.sep` обеспечивает кроссплатформенную совместимость скрипта.
3.  **Преобразование координат:** Координаты ограничивающих рамок (`x`, `y`, `width`, `height`) в JSON-файле представлены в процентах от оригинальных размеров изображения. Скрипт пересчитывает их в абсолютные пиксельные значения для корректного отображения на изображении.
4.  **Визуализация:** Для удобства просмотра, особенно больших изображений, в скрипте реализована функция масштабирования отображаемого окна до заданных максимальных размеров.

**Пример Python-скрипта для визуализации (без изменений, так как он уже был хорошо проработан):**
```python
import json
import cv2
import os

# --- НАСТРОЙКИ ---
# !!! ЗАМЕНИТЕ ЭТО НА ВАШ РЕАЛЬНЫЙ ПУТЬ К ДИРЕКТОРИИ, СОЗДАННОЙ НА ШАГЕ 1.3.1 !!!
BASE_HOST_PATH_TO_LABEL_STUDIO_DATA = r"C:\Users\maxku\Desktop\comparing-data-markup\label_studio_data" # ИЛИ /путь/к/вашей/папке/label_studio_data

# Путь к экспортированному JSON файлу
EXPORTED_JSON_PATH = "project-1-at-....json" # Замените на имя вашего файла

MAX_DISPLAY_WIDTH = 1280
MAX_DISPLAY_HEIGHT = 720
WINDOW_NAME_PREFIX = "Label Studio Annotation Viewer"
# --- КОНЕЦ НАСТРОЕК ---

def visualize_annotations(json_path, base_data_path):
    if not os.path.exists(json_path):
        print(f"Ошибка: Файл аннотаций не найден: {json_path}")
        return
    if not os.path.isdir(base_data_path): # Проверка, что это директория
        print(f"Ошибка: Базовая директория данных Label Studio не найдена или не является директорией: {base_data_path}")
        return

    with open(json_path, 'r', encoding='utf-8') as f:
        tasks = json.load(f)

    for i, task in enumerate(tasks):
        task_id = task.get("id", f"unknown_task_{i}")
        task_id_str = str(task_id)
        print(f"\nОбработка задачи ID: {task_id_str}")

        image_path_from_json = task.get("data", {}).get("image")
        if not image_path_from_json:
            print(f"  Предупреждение: Путь к изображению не найден в задаче ID: {task_id_str}")
            continue

        # Преобразование пути из формата контейнера в формат хоста
        if image_path_from_json.startswith('/data/'):
            relative_path_in_container = image_path_from_json[len('/data/'):].lstrip('/')
            path_parts = relative_path_in_container.split('/')
            # Файлы на хосте лежат в 'media' относительно base_data_path
            correct_relative_path_on_host = os.path.join("media", *path_parts)
            full_image_path_on_host = os.path.join(base_data_path, correct_relative_path_on_host)
        else:
            print(f"  Предупреждение: Нестандартный путь к изображению: {image_path_from_json}. Попытка использовать как относительный от {base_data_path}.")
            full_image_path_on_host = os.path.join(base_data_path, image_path_from_json.lstrip('/\\'))


        if not os.path.exists(full_image_path_on_host):
            print(f"  Ошибка: Файл изображения не найден на хосте: {full_image_path_on_host}")
            print(f"  Убедитесь, что BASE_HOST_PATH_TO_LABEL_STUDIO_DATA ('{base_data_path}') указан корректно и содержит папку 'media/upload/...'.")
            continue
        
        print(f"  Загрузка изображения: {full_image_path_on_host}")
        original_image = cv2.imread(full_image_path_on_host)
        if original_image is None:
            print(f"  Ошибка: Не удалось загрузить изображение: {full_image_path_on_host}")
            continue

        display_image = original_image.copy()
        img_h_orig, img_w_orig = original_image.shape[:2] # Получаем оригинальные размеры

        for annotation_bundle in task.get("annotations", []):
            for result_item in annotation_bundle.get("result", []):
                if result_item.get("type") == "rectanglelabels":
                    value = result_item["value"]
                    # Используем original_width/height из самой аннотации, если они есть, иначе из изображения
                    img_width_for_calc = result_item.get("original_width", img_w_orig)
                    img_height_for_calc = result_item.get("original_height", img_h_orig)

                    label_text = ", ".join(value.get("rectanglelabels", ["Unknown"]))
                    
                    x_percent = value.get("x", 0)
                    y_percent = value.get("y", 0)
                    width_percent = value.get("width", 0)
                    height_percent = value.get("height", 0)

                    x1 = int((x_percent / 100.0) * img_width_for_calc)
                    y1 = int((y_percent / 100.0) * img_height_for_calc)
                    x2 = int(((x_percent + width_percent) / 100.0) * img_width_for_calc)
                    y2 = int(((y_percent + height_percent) / 100.0) * img_height_for_calc)

                    color = (0, 255, 0) 
                    line_thickness = max(1, int(min(img_width_for_calc, img_height_for_calc) / 300)) # Адаптивная толщина линии
                    font_scale = max(0.4, min(img_width_for_calc, img_height_for_calc) / 1000)      # Адаптивный размер шрифта


                    cv2.rectangle(display_image, (x1, y1), (x2, y2), color, line_thickness)
                    (text_width, text_height), baseline = cv2.getTextSize(label_text, cv2.FONT_HERSHEY_SIMPLEX, font_scale, line_thickness)
                    text_y_pos = y1 - 10 if y1 - 10 > text_height else y1 + text_height + baseline + 5
                    cv2.putText(display_image, label_text, (x1, text_y_pos),
                                cv2.FONT_HERSHEY_SIMPLEX, font_scale, color, line_thickness)
        
        if MAX_DISPLAY_WIDTH > 0 and MAX_DISPLAY_HEIGHT > 0:
            h_disp, w_disp = display_image.shape[:2]
            scale = min(MAX_DISPLAY_WIDTH / w_disp, MAX_DISPLAY_HEIGHT / h_disp)
            if scale < 1: 
                new_w, new_h = int(w_disp * scale), int(h_disp * scale)
                resized_display_image = cv2.resize(display_image, (new_w, new_h), interpolation=cv2.INTER_AREA)
            else:
                resized_display_image = display_image
        else:
            resized_display_image = display_image

        current_window_name = f"{WINDOW_NAME_PREFIX} - Task: {task_id_str} ({i+1}/{len(tasks)})"
        cv2.imshow(current_window_name, resized_display_image)
        
        print(f"  Отображена задача {task_id_str}. Нажмите любую клавишу для следующей, ESC для выхода.")
        key = cv2.waitKey(0)
        
        try:
            cv2.destroyWindow(current_window_name)
        except cv2.error as e:
            print(f"  Info: Не удалось закрыть окно '{current_window_name}' (возможно, закрыто пользователем): {e}")

        if key == 27:  # ESC
            print("Выход по требованию пользователя.")
            break
    
    cv2.destroyAllWindows()
    print("\nПроверка завершена.")

if __name__ == "__main__":
    # Убедитесь, что пути ЗАМЕНЕНЫ на актуальные перед запуском
    if BASE_HOST_PATH_TO_LABEL_STUDIO_DATA == r"C:\Users\maxku\Desktop\comparing-data-markup\label_studio_data" or \
       BASE_HOST_PATH_TO_LABEL_STUDIO_DATA == "/путь/к/вашей/папке/label_studio_data" or \
       EXPORTED_JSON_PATH == "project-1-at-....json":
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        print("!!! ВНИМАНИЕ: Пожалуйста, обновите пути в скрипте (BASE_HOST_PATH_TO_LABEL_STUDIO_DATA и EXPORTED_JSON_PATH) !!!")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    else:
        visualize_annotations(EXPORTED_JSON_PATH, BASE_HOST_PATH_TO_LABEL_STUDIO_DATA)

```

**Инструкция по использованию скрипта:**
1.  Сохраните приведенный выше Python-код в файл (например, `view_ls_annotations.py`).
2.  **Важно:** В скрипте, в секции `--- НАСТРОЙКИ ---`, **замените** значение переменной `BASE_HOST_PATH_TO_LABEL_STUDIO_DATA` на ваш актуальный путь к директории, где хранятся данные Label Studio (папка, созданная на шаге 1.3.1).
3.  **Замените** значение переменной `EXPORTED_JSON_PATH` на имя вашего экспортированного JSON-файла с аннотациями. Рекомендуется поместить JSON-файл в ту же директорию, что и скрипт, или указать полный путь к нему.
4.  Убедитесь, что у вас установлен Python и библиотеки OpenCV (`opencv-python`) и NumPy (`numpy`).
5.  Запустите скрипт из терминала или командной строки: `python view_ls_annotations.py`.
6.  Изображения с наложенными ограничивающими рамками и метками будут отображаться по очереди. Для перехода к следующему изображению нажмите любую клавишу, для завершения просмотра – клавишу `ESC`.

**Результат проверки:** Визуализация с помощью данного Python-скрипта позволила подтвердить, что аннотации, сделанные в Label Studio и экспортированные в формате JSON, корректно соотносятся с исходными изображениями. Ограничивающие рамки были наложены на соответствующие объекты согласно разметке.

## 4. Впечатления от первого опыта использования Label Studio

*   **Удобство интерфейса:**
    *   **Положительные моменты:** Основной интерфейс для создания проектов, импорта данных и непосредственной разметки (аннотирования) интуитивно понятен. Процесс рисования ограничивающих прямоугольников (bounding boxes) прост и удобен. Возможность настройки горячих клавиш является существенным плюсом для ускорения работы. Интерактивные элементы управления масштабированием и панорамированием изображения облегчают точную разметку.
*   **Понятность настроек:**
    *   **Положительные моменты:** Наличие готовых шаблонов для интерфейса разметки значительно упрощает первоначальную настройку для стандартных задач. Базовые настройки проекта (имя, описание) ясны.
    *   **Области, требующие внимания:** Глубокая кастомизация интерфейса разметки с помощью XML-конфигурации требует времени на изучение документации по специфическим тегам и атрибутам Label Studio. Структура экспортируемых данных (особенно пути к файлам в JSON и формат координат) требует внимательного анализа при разработке скриптов для последующей программной обработки аннотаций.
*   **Возникшие вопросы или трудности при разметке и работе:**
    *   **Сопоставление путей к файлам:** Наиболее значимой трудностью было понимание того, как Label Studio, работающий в Docker-контейнере, обрабатывает пути к файлам. Пути, указанные в экспортированном JSON (`/data/upload/...`), являются внутренними для контейнера. Для доступа к этим файлам из хост-системы (например, в Python-скрипте для проверки) потребовалось корректно сопоставить их с путями в смонтированном томе на хосте (через поддиректорию `media/`).
    *   **Координаты в процентах:** Аннотации Bounding Box экспортируются с координатами и размерами в процентах от исходных размеров изображения. Это требует их пересчета в абсолютные пиксельные значения для визуализации или использования в некоторых ML-фреймворках.
    *   **Выбор метки при разметке:** Для тестовой задачи с двумя метками это не вызвало проблем. Однако при работе с большим количеством классов объектов может потребоваться более эффективный механизм выбора нужной метки (например, поиск по названию метки или более развитая система горячих клавиш для каждой метки).
*   **Общее впечатление:** Label Studio произвел впечатление мощного и гибкого инструмента для разметки данных. Развертывание через Docker с монтированием локального тома является надежным способом организации работы и обеспечивает сохранность данных. Основные задачи разметки (в данном случае, детекция объектов) выполняются относительно легко и интуитивно. Для эффективной интеграции результатов разметки в последующие этапы MLOps-пайплайна ключевым является понимание структуры экспортируемых данных и особенностей работы с путями к файлам при использовании Docker. Возможность автоматизированной проверки качества разметки с помощью внешних скриптов, подобных разработанному, является важным элементом контроля.

## 5. Заключение
Задача по развертыванию Label Studio с использованием Docker, выполнению тестового набора разметки изображений, экспорту аннотаций и их последующей визуальной проверке была успешно выполнена. В ходе работы был получен ценный практический опыт взаимодействия с инструментом, выявлены ключевые аспекты его настройки и использования, а также потенциальные сложности (в частности, связанные с управлением путями к файлам при работе в Docker-окружении) и предложены методы их решения. Процесс был детально задокументирован в настоящем отчете, который может служить практическим руководством для новых пользователей, планирующих использовать Label Studio на платформах Windows или Linux.
